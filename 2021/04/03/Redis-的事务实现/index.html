<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Redis 的事务实现 | 编程学习记录</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Redis 的事务实现</h1><a id="logo" href="/.">编程学习记录</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Redis 的事务实现</h1><div class="post-meta">Apr 3, 2021<span> | </span><span class="category"><a href="/categories/Redis/">Redis</a></span></div><div class="post-content"><p>&emsp;&emsp;Redis 的事务提供了一种将多个命令请求打包，然后一次性、按顺序地指向多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。</p>
<a id="more"></a>
<p>&emsp;&emsp;事务是以一个 MULTI 命令开始，接着将多个命令放入事务中，最后由 EXEC 命令将这个事务提交给服务器执行。</p>
<h2 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h2><p>&emsp;&emsp;一个事务从开始到结束会经历以下三个阶段:</p>
<ol>
<li>事务开始</li>
<li>命令入队</li>
<li>事务执行</li>
</ol>
<h3 id="事务开始"><a href="#事务开始" class="headerlink" title="事务开始"></a>事务开始</h3><p>&emsp;&emsp;MULTI 命令标志着事务的开始。</p>
<h3 id="命令入队"><a href="#命令入队" class="headerlink" title="命令入队"></a>命令入队</h3><p>&emsp;&emsp;当一个客户端处于非事务状态时，这个客户端发送的执行命令会立即被服务器执行；与此不同的是，当一个客户端处于事务状态时，服务器会根据不同的命令执行不同的操作:</p>
<ul>
<li>若客户端发送的是命令是 EXEC、DISCARD、WATCH、MULTI 这四个命令中的一个，服务器会立即执行该命令。</li>
<li>与此相反，如果客户端发送的命令不是这四个命令，那么服务器不是立即执行命令，而是将命令放入事务队列里面，然后向客户端返回 QUEUED 回复。</li>
</ul>
<h3 id="事务队列"><a href="#事务队列" class="headerlink" title="事务队列"></a>事务队列</h3><p>&emsp;&emsp;每个 Redis 客户端都有自己的事务状态，这个事务状态保存在客户端状态的 mstate 属性里面:</p>
<figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 事务状态</span></span><br><span class="line">	multiState mstate;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125; redisClient'</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;事务状态包含一个事务队列，以及一个已入对命令的计数器(事务队列的长度):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiState</span> &#123;</span></span><br><span class="line">	<span class="comment">// 事务队列,FIFO 顺序</span></span><br><span class="line">	multiCmd *commands;</span><br><span class="line">	<span class="comment">// 已入队命令计数</span></span><br><span class="line">	<span class="keyword">int</span> count;</span><br><span class="line">&#125;multiState;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;事务队列是一个 multiCmd 类型的数组:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiCmd</span>&#123;</span></span><br><span class="line">	<span class="comment">// 参数</span></span><br><span class="line">	robj **argv;</span><br><span class="line">	<span class="comment">// 参数数量</span></span><br><span class="line">	<span class="keyword">int</span> argc;</span><br><span class="line">	<span class="comment">// 命令指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span></span><br><span class="line">&#125;multiCmd;</span><br></pre></td></tr></table></figure>
<h3 id="执行事务"><a href="#执行事务" class="headerlink" title="执行事务"></a>执行事务</h3><p>&emsp;&emsp;当一个处于事务状态的客户端向服务器发送 EXEC 命令时，这个 EXEC 命令将立即被服务器执行。服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得的结果全部返回给客户端。</p>
<h2 id="WATCH-命令的实现"><a href="#WATCH-命令的实现" class="headerlink" title="WATCH 命令的实现"></a>WATCH 命令的实现</h2><p>&emsp;&emsp;WATCH 命令是一个乐观锁( optimistic locking ),它可以在 EXEC 命令执行之前，监视任意数量的数据库键，并在 EXEC 命令执行时，检查被监视的键是否至少有一个已经被修改过了，如果是的话，服务器将拒绝执行事务，冰箱客户端返回代表事务执行失败的空回复。</p>
<h3 id="使用-WATCH-命令监视数据库键"><a href="#使用-WATCH-命令监视数据库键" class="headerlink" title="使用 WATCH 命令监视数据库键"></a>使用 WATCH 命令监视数据库键</h3><p>&emsp;&emsp;每个 Redis 数据库都保存着一个 watched keys 字典，这个字典的键时某个被 WATCH 命令监视的数据库键，而字典的值是一个链表，记录所有监视相应数据库键的客户端:</p>
<figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// 正在被 WATCH 命令监视的键</span></span><br><span class="line">	dict *watched_keys;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;redisDb;</span><br></pre></td></tr></table></figure>
<h3 id="监控机制的触发"><a href="#监控机制的触发" class="headerlink" title="监控机制的触发"></a>监控机制的触发</h3><p>&emsp;&emsp;所有对数据库进行修改的命令，在执行完成之后都会调用 multi.c/touchWatchKey 函数对 watched_keys 字典进行检查，查看是否有客户端正在监视刚刚被命令修改过的数据库键，如果有的话，那么 touchWatchWay 函数会将监视被修改键的客户端的 REDIS_DIRTY_CAS 标示打开，表示该客户端的事务安全性已经被破坏。</p>
<h3 id="判断事务是否安全"><a href="#判断事务是否安全" class="headerlink" title="判断事务是否安全"></a>判断事务是否安全</h3><p>&emsp;&emsp;当服务器接收到一个客户端发来的 EXEC 命令时，服务器会根据这个客户端是否打开了 REDIS_DIRTY_CAS 标识来决定是否执行事务:</p>
<ul>
<li>若 REDIS_DIRTY_CAS  标识已经被打开，说明客户端监视的键中至少有一个被修改过了，客户端提交的事务已经不再安全，所以服务器会拒绝执行客户端提交的事务。</li>
<li>若 REDIS_DIRTY_CAS  标识没用被打开，说明事务安全。</li>
</ul>
<h2 id="事务的-ACID"><a href="#事务的-ACID" class="headerlink" title="事务的 ACID"></a>事务的 ACID</h2><p>&emsp;&emsp;在 Redis 中，事务总是具有原子性( Atomicity )、一致性( Consistency )和隔离性( Isolation )，并且当 Redis 运行在某种特定的持久化模式下时，事务也具有耐久性( Durability )。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>&emsp;&emsp;对于 Redis 的事务功能来说，事务队列中的命令要么就全部执行，要么就一个都不执行，因此，Redis 的事务是具有原子性的。</p>
<p>&emsp;&emsp;Redis 的事务和传统的关系型数据库事务的最大区别在于，Redis 不支持事务回滚机制，即使事务队列中的某个命令在执行期间出现错误，整个事务也会继续执行，直到事务队列中所有的命令都执行完成。Redis 的作者在事务功能的文档中解释说，不支持事务回滚是因为这种复杂的功能和 Redis 追求简单高效的设计主旨不符，并且他认为，Redis 事务的执行时错误通常都是编程错误产生的，这种错误通常只会出现在开发环境中，而很少会在实际的生成环境中出现，所以没必要为 Redis 开发事务回滚功能。</p>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>&emsp;&emsp;事务的一致性指的是，如果数据库在执行事务之前是一致的，那么在事务执行之后，无论事务是否执行成功，数据库也应该仍然是一致的。Redis 通过谨慎的错误检测和简单的设计来保证事务的一致性。</p>
<h4 id="入队错误"><a href="#入队错误" class="headerlink" title="入队错误"></a>入队错误</h4><p>&emsp;&emsp;如果一个事务在入队命令的过程中，出现了命令不存在，或者命令的格式不正确等情况，那么 Redis 将拒绝执行这个事务。</p>
<h4 id="执行错误"><a href="#执行错误" class="headerlink" title="执行错误"></a>执行错误</h4><p>&emsp;&emsp;执行的过程中发生错误:</p>
<ul>
<li>执行过程中发生的错误都是一些不能在入队时被服务器发现的错误，这些错误只会在命令实际执行时被触发。</li>
<li>即使在事务的执行过程中发生了错误，服务器也不会中断事务的执行，它会继续执行事务中余下的其他命令，并且已执行的命令(包括执行命令所产生的结果)不会被出错的命令影响。</li>
</ul>
<h4 id="服务器停机"><a href="#服务器停机" class="headerlink" title="服务器停机"></a>服务器停机</h4><p>&emsp;&emsp;Redis 服务器在执行事务的过程中停机，那么根据服务器所使用的持久化模式，可能有以下情况出现:</p>
<ul>
<li>如果服务器运行在无持久化的内存中，重启之后数据库将是空白的，因此数据总是一致的。</li>
<li>如果服务器运行在 RDB 模式下，那么事务中途停机不会导致不一致性，因为服务器可以根据现有的 RDB 文件恢复数据，从而将数据库还原到一个一致的状态，如果找不到可用的 RDB 文件，重启之后是空白的，空白数据库总是可用。</li>
<li>如果服务器运行在 AOF 模式下，那么事务中途停机不会导致不一致，因为服务器可以根据现有的 AOF 文件来恢复数据，从而将数据库还原到一个一致的状态。如果找不到可供使用的 AOF 文件，那么重启之后的数据库将是空白的， 而空白数据库总是一致的。</li>
</ul>
<p>&emsp;&emsp;综上所述，无论 Redis 服务器运行在哪种持久化模式下，事务执行中途发生的停机都不会影响数据库的一致性。</p>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>&emsp;&emsp;事务的隔离性指的是，即使数据库中有多个事务并发地执行，各个事务之间也不会互相影响，并且在并发状态下执行的事务和串行执行的事务产生的结果完全相同。</p>
<p>&emsp;&emsp;因为 Redis 使用单线程的方式来执行事务(以及事务队列中的命令)，并且服务器保证，在执行事务期间不会对事务进行中断，因此，Redis 的事务总是以串行的方式运行的，并且事务也总是具有隔离性。</p>
<h3 id="耐久性"><a href="#耐久性" class="headerlink" title="耐久性"></a>耐久性</h3><p>&emsp;&emsp;事务的耐久性指的是，当一个事务执行完毕时，执行这个事务所得的结果已经被保存到永久性存储介质里了，即使服务器在事务执行完毕之后停机，执行事务所得的结构也不会丢失。</p>
<p>&emsp;&emsp;当服务器运行在 AOF 模式下，并且同步刷盘，将命令数据真正地保存在硬盘中，这种情况下是具有耐久性的。</p>
<p>&emsp;&emsp;不论在什么模式下，在一个事务的最好加上 SAVE 命令总可以保证事务的耐久性。(不过这种做法效率太低，不具有实用性。)</p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2021/04/05/Redis中的数据结构与对象/">Redis中的数据结构与对象</a><a class="next" href="/2021/02/18/二叉树的前中后序遍历/">二叉树的前中后序遍历</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Scala/">Scala</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发经验/">开发经验</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构与算法/">数据结构与算法</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/06/30/AbstractQueuedSynchronizer-的基本认识/">AbstractQueuedSynchronizer 的基本认识</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/05/Redis中的数据结构与对象/">Redis中的数据结构与对象</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/03/Redis-的事务实现/">Redis 的事务实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/18/二叉树的前中后序遍历/">二叉树的前中后序遍历</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/04/union-find/">union find</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/27/基础排序-冒泡排序及其变体/">基础排序-冒泡排序及其变体</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/09/Rails响应请求的过程/">Rails 响应 Web 请求的过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/20/JVM的运行时数据区域、垃圾回收以及类加载机制/">JVM的运行时数据区域、垃圾回收以及类加载机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/30/MacOS-10-15-安装-Rails-环境/">MacOS 10.15 安装 Rails 环境</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/10/Scala-中的尾递归/">Scala 中的尾递归</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">编程学习记录</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>